# Chapter 3 Code Smell

- 전반적으로 이 챕터에서는 클린 코드와 유사하게 코드에서 나는 악취에 대해 얘기하면서 리팩터링을 언제 멈추느냐가 아닌 리팩터링으로 해결할 수 있는 다양한 문제를 제시한다.

## 3.1
- 모호한 이름의 변수가 많다면 그 역시 설계상에 근복적으로 큰 문제가 도사리고 있을 수도 있다.

## 3.2 ~ 3.4
- 중복 코드, 긴 함수, 긴 매개변수 목록

## 3.5
- Code Smell에서 가장 심한 악취는 전역 데이터다.
- 대표적인 유형이 싱글턴 패턴에 대한 내용이다.
- 어디서든 전역에서 건드릴 수 있기때문에 수정 접근 범위에 대해 통제가 힘들기때문이다.

## 3.6 가변데이터

## 3.7 ~ 8 뒤엉킨 변경, 산탄총 수술
- 하나의 모듈이 여러 방식으로 변경되는 일에 대해 설명하고, 여기서 설계 원칙의 SRP 원칙을 위반했을 때 자주 나타나는 유형이다.
- 단일 책임을 갖고 있지 않았을 때 여러 작업을 한 모듈이 실행하게 되는 경우이다.
- 특정 객체가 추가가 될 때 모듈의 함수를 여러 개 수정해야 될 때가 적절한 예시.
- 산탄총 수술은 뒤엉킨 변경이랑은 유사하면서 정반대 -> 코드를 수정할 때 마다 수정해야하는 클래스(객체)들이 많을 때다.

## 3.9 ~ 10 기능 편애, 데이터 뭉치
- 많은 상호작용이나 많은 코드 뭉치

## 3.11 기본형(원시 자료형) 집착
- 데이터를 만들 때 화폐, 날씨 등과 같은 유니크한 단위들에 대해 정의하기를 꺼려해서 보편적으로 사용할 때마다 단위를 무시하고 편하게 코드를 작성하는 사례가 많다.
- 그렇게 하는 것보다 원시 자료형들을 객체로 만들어서 유니크한 단위들에 대한 객체를 사용해서 작업하는 것이 좋다

## 3.12 ~ 24
- 이 외에도 반복되는 분기처리문, 반복문, 추측성 일반화(나중에 사용될 것이라고 추측되는 객체를 만드는?) , 임시필드, 메시지 체인 등이 존재하고
- 3.18의 중개자, 내부자 거래 같은 것은 결국 결합도와 연관 있으므로 결합도를 줄이기 위해 모듈 사이의 데이터 교환을 자제하며 인스턴스와의 상호작용을 위임하지 않고 다이렉트로 하는 중개자 제거 등을 적용한다.
- 그 밖에도 클래스와 관련한 내용들이 있고 상속 포기 같은 경우에 부모 클래스의 구현을 따르진 않아도 인터페이스를 따르지 않겠다면 사실상 서브클래스 위임 같은 방법으로 상속과 관련돼서 처리하는 것이 좋다.

## 결론
- 이 챕터에서는 클린 코드에서 설명하는 코드 악취와 더불어 리팩터링을 활용하기에 적합한 상황들에 대한 열거를 통해 효율적으로 리팩터링을 하게 권하고 있다.
- 실제로 객체지향 언어에서 상속과 추상화, 다형성 등 다양하게 쓰고 있으므로 수시로 점검해서 감을 길러야 한다.

