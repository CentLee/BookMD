# Chapter 7 캡슐화

## 7.1 레코드 캡슐화
- 해당 장에서는 흔히 사용하는 데이터들을 클래스 데이터로 캡슐화 하는 방법에 대해 소개함.
- 일반적인 객체지향 프로그래밍 언어를 다루는 개발자라면 흔히 사용하는 기본적인 케이스

## 7.2 컬렉션 캡슐화
- 이 장 또한 캡슐화 하는 방법에 대해 소개하지만, 컬렉션 같은 가변 데이터를 캡슐화하는 과정에서는 세밀함이 필요하다.
- 원본 모듈 밖에서 해당 클래스나 객체들에 대해서 수정하려하고 객체 자체를 반환받아서 사용한다고 하면 내부의 원소들이 알게 모르게 바뀔 수 있다.
- 이런 점을 해결하기 위해 add remove 와 같은 알기 쉬운 메소드를 객체 내부에 포함시켜서 캡슐화를 하면 협업을 하는 과정에서도 쉽게 버그에 대응할 수 있다.


~~~swift
class Person {
  var name: String = ""
  var courses: [Course] = [Course()]
}

class Course {
  var name: String = ""
  var isAdvanced: Bool = false
}
이 경우일 때 코스 리스트 자체를 반환받아서 직접 코스에 대해서 수정을 하려한다면, 더이상 Person 클래스는 Course를 통제할 수 없게된다.
이 문제점이 7.2에서 말하는 문제점
~~~

## 7.3 Primitive to Object
- 원시 자료형들을 객체(클래스 혹은 구조체)로 변환시켜 사용하게 한다.

## 7.4 Replace Temp with Query
- 같은 결과값을 내는 코드가 있을 때, 변수를 그때마다 만들어 분기처리나 또다른 작업을 하지않고, 반환 메소드를 만들어서 반환된 값만을 이용해서 또다른 작업을 하게한다.

## 7.5 클래스 추출하기
- 7장에서 가장 중요한 부분이라고 생각된다.
- 클래스 자체는 SRP를 위반하지않고, 10 to 200 원칙을 지켜서 코드 작성하는 것을 고수하려고 하지만 특정 데이터와 일부 메소드를 함께 다른 클래스로 추출하는 방법을 택하지않고,,
- 단순 코드 몇 줄을 추가하며 역할을 늘려나가는 방법을 택하게 되는 상황들이 발생하는데 이러한 부분이 클래스를 비대하게 만든다.
- 따라서 해당 클래스의 기준에 맞게 역할들을 분리하고 그 역할에 맞게 다른 클래스로 추출하는 방벙을 택한다.

## 7.6 클래스 인라인하기
- 7.5와는 반대로 거꾸로 돌리는 리팩터링이다.
- 제 역할을 못하는 객체가 존재한다면 상위 객체로 포함시켜버린다.
- 따라서 클래스의 역할을 분리하는 작업이 인터페이스 설계 측면에서도 중요하다고 생각한다.

## 7.7 위임 숨기기
- 클라이언트 입장에서 볼 수 없게 알지 않아도 되는 것들을 숨기는 방식인데, 의존성을 줄이는 방법과 유사하다.

## 7.8 중개자 제거하기
- 위임 숨기기와는 반대의 동작이다.
- 위임 숨기기를 해서 의존성을 줄이더라도 그 이점을 얻으려면 다른 메소드를 사용해야한다면 또 프로토콜이나 Delegate 객체에 메소드를 그때마다 추가해야한다는 단점이 있다.
- 그렇다면 이벤트를 받는 VC 나 View 같은 객체는 Delegation하기 위한 중개자로 전락하게 된다.
- 이럴 때엔 중개자를 제거하고 클라이언트가 직접 호출할 수 있게 한다.
- 앱에서는 어떠한 방식으로 이 방법을 적용하는 지 궁금?

## 7.9 알고리즘 교체하기
- 예를 들어 분기처리하는 구문이 있을 때 이런 부분을 고차함수나 다른 함수 혹은 알고리즘을 사용하여 교체하는 방법을 말한다.

## 결론
- 결국 캡슐화라는 것 자체도 설계의 일부분으로써 인터페이스와 설계의 부분이 얼마나 중요한 지 계속 책을 읽으면서 새삼 깨닫게 되고 기본기에 더 근접하고 있다고 생각한다.
