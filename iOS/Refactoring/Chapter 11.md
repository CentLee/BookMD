# Chapter 11 API Refactoring 
- 클래스는 대표적인 모듈이다.

## 11.1 질의 함수와 변경 함수 분리하기
- 이 방법은 질의 함수에서 부수 효과를 낳는 부분은 분리 제거해서 질의 함수 목적에 맞게 연산을 통해 값을 반환하는 동작만 수행하게끔 하는 방법이다.

## 11.2 함수 매개변수화하기
- 특정 객체에 대해 연산을 진행할 때 예를 들어 비율을 곱하거나 하는 계산 연산에 대해서 그 계산 마다 함수를 만들어 따로 하지말고 매개변수로 비율 자체도 같이 전달받아서 작업을 진행하도록 하는 방법이다.

## 11.3 플래그 인수 제거하기
- 여기서 플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택할 수 있게 전달하는 인수이다.
- 참 거짓, 이름 등 구분 - 분기처리할 수 있는 변수들을 일컫는데 그런 부분들을 값 각각에 대응하는 명시적 함수를 만들면 더욱 깔끔해진다.
- 플래그 인수를 전달하는 것을 제거하는 것이 아니라, 플래그 인수는 전달하되 조건문 분해하기를 통해서 새로 함수를 만들어 의도를 명확하게 하고 새로운 함수를 다이렉트로 호출하는 것으로 변경한다.

## 11.4 객체 통째로 넘기기
- 한 객체의 값 여러 개를 매개변수로 각각 넘기는 게 아니라 객체를 통째로 넘기고 함수 본문에서 필요한 값을 꺼내서 쓰도록하게 한다. 
- 함수 본문이 매개변수를 더 다양하게 사용하더라도 매개변수 목록 자체를 수정할 일은 없다. 그래서 함수자체를 수정할 일이 줄어든다는 얘기다.

## 11.5 매개변수를 질의 함수로 변경하기
- 호출하는 쪽을 간소화시키기 위한 방법이다.
- 매개변수를 없애는 대신 가변 전역변수를 이용하는 것은 절대 금물.

## 11.6 질의 함수를 매개변수로 바꾸기
- 11.5와는 반대의 동작인데 함수 안에 두기에 거부감이 드는 참조에 대해 호출하는 책임자에게 책임을 다시 옮기는 것이다.
- 참조 투명하지 않은 변수에 접근하는 모든 함수는 참조 투명성을 잃는다.
- 질의 함수는 호출자의 책임을 줄이기때문에 내부에서 참조를 하게 되는데 이때 전역변수 같은 것들은 호출자가 직접 매개변수로 넘겨야 특정 값에 대해 특정 결과가 나오는 참조 투명성을 지킬 수 있다.

## 11.7 세터 제거하기
- 이 방법은 되도록 객체가 불변성을 유지하기 위해 세터를 제거하는 방법이다.
- 세터를 제거한다는 것은 생성 시에만 해당 필드가 설정되며 이후에는 수정이 없다는 것을 말한다.
- 예를 들어 유니크한 식별자와 같은 값들은 객체를 생성하고 값을 주입하는 게 아니라 생성 시 Swift에선 Desinated Initialize에서만 설정하도록 변경해야한다.

## 11.8 생성자를 팩토리 함수로 바꾸기
- 객체를 생성하기보다 팩토리 함수를 통해서 함수 본문에서 객체를 생성하도록 하는 방법이다.

## 11.9 함수를 명령으로 바꾸기
- 함수 자체를 함수 만을 위한 객체 안으로 캡슐화하는 방법인데, Command Pattern을 활용한다.
- Command Pattern은 Command 객체와 ConCrete(연산을 실행하는) 객체가 따로 있어, 명령만 하달하도록 하는 장점이 있다.

## 11.10 명령을 함수로 바꾸기
- 11.9와는 반대의 동작이다. 명령 객체 자체가 큰 연산들을 작게 세분화해서 세분화된 메소드끼리 정보 공유하는 여러 이점도 있지만 애초에 규모가 크지 않다면 단순 함수로 바꾸는 것이 더 낫다.

## 11.11 수정된 값 반환하기
- 함수 자체에 반환 값을 만들어서 코드 라인을 줄이고 객체 초기화 시 같이 사용해서 좀 더 명확하게 만드는 작업이다.

## 11.12 오류 코드를 예외로 바꾸기
- 오류에 대한 처리를 좀 더 명확하게 Swift에서는 Error Throw와 같이 특정 예외 케이스에 대해 처리를 할 여러 방법이 있으니 그런 방법을 활용해 예외와 에러 처리에 대해 확실하게 구분해둬야한다.

## 11.13 예외를 사전확인으로 바꾸기
- 예외 자체에 대한 코드 또한 라인 수가 늘어나기 때문에 간단한 동작이라면 guard라든지 삼항 연산자와 같은 방법을 활용해서 사전 확인한 후 작업을 할 수 있도록 리팩터링 할 수 있다.

